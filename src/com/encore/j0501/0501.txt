

<interface> 인터페이스
  형식)
    interface 인터페이스명
    {
       //필드
       [고정 public static final] int su=10;// final변수는 값을 초기화해서 유지할 값을 명시!!
       
       //선언된 메소드 
       [고정 public abstract] void print();
    }
   ------>  저장: 인터페이스명.java  ---컴파일---> 인터페이스명.class
   
 - 클래스에 다중 상속을 구현할 수 있다.
 - interface의 구성멤버는 필드, 선언된 메소드로만 구성.   
    void print(){
    
    } -----> 정의된 메소드, 구현된 메소드!!
    
    void print();  ----> 선언된 메소드 (바디없는,영역괄호없는 메소드)
    
 - 서로 다른 제품에 연결할 수 있는 공통연결 모듈을 의미.
 - ★인터페이스는 어떻게 사용? 클래스에 구현해서 사용!!
                              ---
                                                           키워드: implements
                                                           
  class 클래스명  implements 인터페이스명
  {            ---------- 
                               구현의 약속
  
  }
  
==================================================
 ※ 오버라이딩(메소드 재정의)시 주의할 점
  ---> 접근제한자는 부모와 같거나  확장해야 함!!
  
  부모클래스                     자식클래스
  디폴트           ---->  디폴트,protected,public               
 protected ---->  protected,public               
 public    ---->  public               
  
<클래스와 인터페이스 간의 상속문법>
class A{}

class B extends A{//extends 뒤에는 상속 받고자 하는 한 개의 클래스만 정의
        //확장 (자식클래스를 확장클래스!!)
}
-----------------------------------------
interface A{}
interface B{}

class C implements  A,B{// A와 B인터페이스내에 선언된 메소드를 C클래스에서 전부 구현.
          //구현

} 
----------------------------------------
interface A{}
class B{}

class C  implements  A  extends B  {
  //에러: 클래스와 인터페이스를 동시에 상속할 때는 클래스 먼저, 인터페이스 나중
  //implements가 먼저 나오면 컴파일러가 extends Object를 추가해줌!!
} ---> (X)

class C  extends B implements A{

} ---> (O)
----------------------------------------
interface A {  void hello(); }
interface B {  void hi(); }

interface C  extends  A,B{
    void good();
}  
----------------------------------------
class A { void hello(){}   }

interface B          A{

} ----> 말이 안됨!!

==================================================
<final>
1. final 자료형 변수명;
   ----> 마지막 변수 : 상수(constant) 
   ----> 상수의 식별을 위해 전체 대문자로 표기.
     예) final int MAX=100;   

2. final 리턴형 메소드명(){}
   ---> 마지막 메소드 : 오버라이딩(메소드 재정의) 할 수 없는 메소드.

3. final class 클래스명{} 
   ---> 마지막 클래스 : 자식클래스를 갖지 않는 클래스
   ---> 완벽한 클래스(자식통한 기능확장을 원치 않는다)
   ---> 보안
  
  예) public final class String{}
  
     public class My extends String{
       //에러발생: final클래스는 extends 뒤에 사용 금지.     
     }
==================================================
<추상클래스> abstract class   
- 후손 class를 제어할 목적으로 사용.
- 객체화 될 수 없는 클래스.
- 구현(정의)된 메소드와 선언된 메소드로 구성.
- 스스로 객체생성 불가(new 사용X), 후손class 객체생성(자식은 부모다!!)해서 사용.

형식)
   abstract class 클래스명{
      //필드선언
      
      public void hello(){} //구현된(정의된) 메소드
      abstract void print();//※주의: 선언된 메소드를 사용하는 경우 반드시 abstract를 명시!!   
   }
  

   class 클래스명{
      public void hello(){}
   }
   
   interface 인터페이스명{
      public void print();
   }

=====================================================================
데이터)  11  22  33
       true  false true
       "길동"   "라임"    "주원"
       'j'  'a'   'v'    'a'
       
     int su1 = 11;  
     int su2 = 22;  
     int su3 = 33;
     
     int su[] = {11, 22, 33};
     boolean b[] = {true,  false, true};
     String str[] = {"길동",   "라임" ,   "주원"};
            번지(인덱스)     str[0]    str[1]    str[2]
    
     char ch[]={'j',  'a',   'v' ,   'a'};  

<배열> Array
- 데이터형이 동일한 자료에 같은(하나의) 변수명을 정의한 자료들의 집합.
- 데이터형이 동일한 자료  ===> 조건
     같은(하나의) 변수명을 정의  ===> 특성
     자료들의 집합.  ===> 정의
     
- 데이터를 구분하기 위해서 번지를 사용.

   int su1; ----> 한 개의 정수를 저장할 준비.
   int su2[]; ----> 여러개의 정수를 저장할 준비.
   
- 시작번지는 0번지
- 첫번째 데이터부터 인덱스(자동번호)가 부여.        
  인덱스는 0부터 시작해서 1씩  증가!!
  
- 배열의 크기가 정해지면 인덱스를 벗어나는 참조를 하면 안됨.
   int su3[]={10,20,30};
       번지 ===>    0  1  2
             -----> 배열의 크기(요소 갯수) : 3 (인덱스 0~2)
   int i=103;
   //103데이터를 변수를 통해 출력
   System.out.println(i);  ---> 103
   //20데이터를 변수를 통해 출력             
   System.out.println(su3[1]);  ---> 20
   System.out.println(su3[3]);
      ===> 에러발생: ArrayIndexOutOfBoundsException !!       

- 배열의 크기(배열의 요소 갯수)를 구하는 속성: 배열명.length !!
- 배열선언시 []는 변수명 앞에 또는 뒤에 붙여도 상관이 없다.
   int su[];
   int []su;
   
   int i;
   int j;
   int k;
   ===> int i,j,k;
   
   차이점)
    int su1[],su2;  ---> su1은 배열, su2는 int변수
    int [] su1,su2;  ---> su1,su2 둘다 배열

 배열 형식)
 1. 자료형 배열명[] = { 데이터List(콤마로 구분되는 데이터) };
   ---> 배열선언과 동시에 데이터를 초기화.(이미 데이터가 확정되었을때 사용)
   ---> ※주의: 배열선언과 데이터 초기화하는 부분을 따로 작성할 수 없음!!
   int [] su;//배열선언
          su = {1,2,3,4,5};// 배열초기화   (X)
 
   int i = 6;
   int [] su = {1,2,3,4,5,6};//선언과 초기화 (O)
   
   A a = new A();
   A [] su2 = {new A(), new A(), a};
 
 2. 자료형 배열명[] = new 자료형[배열크기]; //---> 1차원배열 객체생성식 : 암기
   ---> 프로그램 실행 도중 데이터 값을 변경할 때 주로 사용.
   ---> 배열선언과 데이터 초기화하는 부분을 따로 작성하는 것이 가능.
   ---> 배열크기[]는 반드시 자료형 뒤에 위치해야 함.
                배열크기는 정수값이 입력되어야함.

    int []su ; //배열선언
          su = new int[5]; //배열초기화
    ===>  int []su = new int[5];//앞으로 int데이터를 5개 받겠습니다.(5개의 빈방만들기!!)
       
               su[0]=11;    
               su[1]=22;    
               su[2]=33;    
               su[3]=44;    
               su[4]=55;    
     ※ 배열객체생성을 하게 되면 그 위치에 상관없이 각 방에는 초기값이 부여됨 (멤버변수처럼)!!




 




















  







                                                             






 
     