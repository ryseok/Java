

<자바프로그램의 구성>
※프로그램의 기본 ----> 클래스(파일)


class ClassName{

} ----> Java클래스
----> ClassName.java (소스파일,text파일)  : 사람이 읽기
         ---컴파일(javac.exe)-----> ClassName.class(Object파일,바이트코드 파일)  : JVM이 읽기
         
class ClassName2{
   public static void main(String args[])
     {
     
     }
} ----> Java클래스, JavaApplication (독립적으로 실행할 수 있는 main()메소드를 포함한 클래스)         
         
=============================================================================
package 상위패키지명.하위패키지명; ---> 패키지 선언, 현재 작성하는 파일(클래스)의 위치를 표현
import 패키지명.클래스명; ----> 외부에서 참조할 클래스들의 위치를 표현
                                                    예)  import java.util.Calendar;           

class 클래스명       extends 부모클래스명{
   Calendar c;
   
   //필드(변수) 선언;
      자료형 변수명;   
    int su;//int su=0;  정수:0, 실수:0.0, 문자:'\u0000', 논리:false, String포함클래스: null(메모리할당X)
   
   //메소드 정의
   void methodName(변수 선언){
      
       메소드 호출(이름 콜)시 실행할 순차적인 문장들;
       
       ==> 변수선언
           int i;
                     변수초기화
                     메소드호출
          System.out.println(su); ---> 0                     
          System.out.println(i);  ---> 에러!!       
           i=20;
          System.out.println(i);  ---> 20출력   
                     
                     조건문
           if(조건식){
                         조건식 결과 참일때 실행할 문장; //----> 0,1번 실행
           }           
                     
                     반복문
           for(초기화; 조건식; 증감자){
                                반복실행할 문장; //-----> 0~무한대 실행           
           }          
                     
   }//메소드 끝

}            
============================================================================
<접근지정자> Access Control
1. public       - 서로 다른 패키지에서도 접근 가능.
2. protected    - 서로 같은 패키지에서 접근 가능.
                  (서로 다른 패키지라도 상속관계에 있는 자식클래스에서는 접근가능)
3. default(생략) - 서로 같은 패키지에서 접근 가능.
4. private      - 같은 클래스내에서만 접근 가능.
                  (같은 클래스내의 멤버끼리만 호출가능 - 외부클래스에서는 호출불가, 정보은닉)

[접근지정자 (public,생략)] class 클래스명{

    [접근지정자 4개] 자료형 변수명;
    
    [접근지정자 4개] 리턴형 메소드명(){
   
    }
}
============================================================================
<생성자> Constructor
- 새로운 객체를 생성하기 위해서 초기화해주는 메소드.

규칙) 1번,2번을 만족하는 메소드를 생성자라고 함.
 1. 생성자의 이름은 반드시 클래스명과 일치(대소문자 일치)
 2. 리턴자료형을 명시하지 않는다. (void조차 X)
 ----> 1,2: 일반 메소드와의 차이점
 
 3. 객체생성시 자동으로 호출.
 4. 클래스내에 생성자가 하나도 없다면
       자바컴파일러가 컴파일시 자동으로 (기본생성자를) 추가.
 ※ 주의) 단, 클래스내에 한개 이상의 생성자가 정의되어 있다면
           컴파일러는 소스코드에 관여하지 않는다!!
 
 class Abc{
   int su;
   My  my;
 
   Abc(){//기본생성자(매개변수 비어있는 생성자) ----> 초기화(값의 할당) 메소드
     //멤버필드에 대한 초기화 작업
     su=10;
     my = new My();
           
     //선행작업      
   }
   
   Abc(String name){//오버로딩 생성자
   
   }
   
   ABc(int age){
     //---> 에러발생: 클래스명과 일치하지 않으므로 일반메소드!! ---> 리턴자료형을 명시해야함.
   }
 
   void hello(){   
   }
 }           
 ==========================================================================
     Abc a = new                   Abc();
             ---                 ---------          
             동적메모리할당 키워드                      기본생성자 호출!!
             
             
         a.hello();
 
     Abc a2 = new                  Abc("홍길동");
                                 --------------
                                                                 오버로딩 생성자 호출!!
                                                                 
         a2.hello();
===========================================================================
<this> 자기참조 연산자
  ===> 현재클래스를 가르키는 레퍼런스변수(참조변수)!!
  ===> 보통은 생략함  
  
1. 메소드 내에서 사용.
2. 객체생성자내에서 다른 생성자를 호출시 사용.
3. 매개변수와 멤버변수(필드)를 구분하기 위해
     멤버변수앞에 this.을 붙여 사용.
     
형식)
    this.필드명
    this.메소드명();
    this();//생성자 호출
참고)
    super.필드명
    super.메소드명();
    super();//부모클래스의 생성자 호출
    
    
    
class A{
   int su;//int su=0;
   String str;//String str=null;
   
   
   A(){//기본생성자
      this("자바");
   }
   
   A(String str){//오버로딩 생성자
      this.str = str;
     //멤버변수       지역변수
   }

   void hello()
   {
     System.out.println("STR="+ str);
   
     System.out.println(su);
     System.out.println(this.su);
     gildong();  ===> this.gildong();
     
   }
   
   void gildong(){
   
   
   }

}    
   
   
    
    
                      
         
                                                                          
                                                                 
 
 
                  
 













                            
















